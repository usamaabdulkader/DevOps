# Bandit Level 2 → Level 3

## Objective

The password for the next level is stored in a file called:

--spaces in this filename--

located in the home directory.

---

## Problem

Running:

```bash
cat spaces in this filename
```

did not work as expected. The shell interpreted each word as a separate argument instead of a single filename.

This highlights a core shell behavior:

The shell splits input on whitespace before executing the command.

The issue was not with `cat`, but with argument parsing.

---

## Solution

To prevent whitespace from splitting the filename, it must be quoted or escaped.

### Option 1 – Quoting

```bash
cat "spaces in this filename"
```

### Option 2 – Escaping

```bash
cat spaces\ in\ this\ filename
```

### Method 3 – Use full path with escaping

```bash
cat /home/bandit2/--spaces\ in\ this\ filename--
```

All approaches ensure the filename is treated as a single argument.

---

## Explanation

- The shell performs tokenization before command execution.
- Whitespace acts as a delimiter between arguments.
- Quoting preserves the entire string as one argument.
- Escaping prevents individual spaces from acting as separators.

Understanding this distinction is essential when working with complex filenames or building automation scripts.

---

## Key Takeaways

- Filenames may legally contain spaces.
- Argument parsing happens before the command runs.
- Quoting and escaping are fundamental for reliable shell usage.
- Many command-line issues stem from parsing, not from the command itself.

---

## Practical Relevance

In real-world environments:

- Scripts often process unpredictable filenames.
- Poor handling of whitespace can break automation.
- CI/CD pipelines and deployment scripts must account for argument parsing behavior.

Understanding shell parsing helps prevent fragile command construction and subtle production failures.