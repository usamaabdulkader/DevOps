# Bandit Level 15 → Level 16

## Objective

Retrieve the password for the next level by submitting the current level’s password to port `30001` on `localhost` using SSL/TLS encryption.

---

## Problem

Unlike the previous level, the service required a TLS-encrypted connection rather than plain TCP.

The challenge was not simply establishing a connection, but:

- Identifying the correct client tool
- Understanding where specific options belong
- Handling newline formatting (`CRLF` vs `LF`)
- Understanding input sequencing during TLS negotiation

The issue was conceptual, not syntactical.

---

## Tool Selection

The service required:

- A TLS connection
- Interactive communication
- Manual submission of plaintext after handshake

This ruled out `nc` and `telnet`, and pointed to:

```bash
openssl s_client
```

A key realization was that `openssl` is a command dispatcher.  
Options such as `-crlf` belong to the `s_client` subcommand, not the base `openssl` command.

Correct documentation reference:

```
man openssl-s_client
```

---

## CRLF Handling

The `-crlf` flag ensures that pressing Enter sends `\r\n` instead of just `\n`.

```bash
openssl s_client -crlf -connect localhost:30001 -servername localhost
```

Without `-crlf`, the TLS handshake succeeded, but the server did not process the password correctly.  
The connection returned TLS-level output (e.g., `DONE`) rather than application-level confirmation.

The handshake layer was functioning, but application framing was incorrect.

---

## Mechanism vs Payload

Command structure must be interpreted precisely:

- Mechanism: `-connect`
- Payload: `localhost:30001`

Understanding this distinction prevents misreading SYNOPSIS sections in man pages and misplacing arguments.

---

## Interactive Success

After the TLS handshake completed:

- The password was entered manually
- The server responded with:

```
Correct!
```

This confirmed:

- TLS negotiation succeeded
- Input formatting was correct
- Data was transmitted during the correct protocol phase

---

## Automation Attempt and Failure

Attempting redirection:

```bash
openssl s_client -crlf -connect localhost:30001 < /etc/bandit_pass/bandit15
```

Result:

```
DONE
```

instead of `Correct!`

This was a sequencing issue, not a syntax error.

Input redirection feeds stdin immediately, before the TLS handshake completes.  
From the server’s perspective, EOF occurred before valid application data was processed.

---

## Explanation

Two distinct phases exist:

1. TLS handshake
2. Application data exchange

Data sent before the handshake completes may be ignored or mishandled.

Redirection (`< file`) differs from interactive input because:

- It supplies input immediately
- It may close stdin before the program is ready
- EOF timing affects protocol behavior

The failure was related to input timing, not encryption.

---

## Key Takeaways

- `openssl` is a dispatcher; flags may belong to subcommands.
- TLS handshake and application data phases are separate.
- CRLF vs LF formatting can affect protocol handling.
- Input redirection alters sequencing.
- EOF behavior matters in stateful network tools.
- Man pages must be navigated contextually, not linearly.

---

## Practical Relevance

This workflow directly applies to:

- Debugging TLS services with self-signed certificates
- Investigating application failures after successful TLS negotiation
- Testing SMTP or custom TLS services
- Automating interactions with stateful network services
- Troubleshooting CI/CD health checks over HTTPS

This level marked a transition from basic networking to protocol-aware debugging and input sequencing analysis.